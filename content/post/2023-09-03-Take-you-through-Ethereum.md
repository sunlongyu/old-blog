---
title:       "Take you through Ethereum"
subtitle:    "start ethereum"
description: ""
date:        2023-09-03
author:      "SLY"
image:       ""
tags:        ["smart contract", "eth", "gosht", "EVM", "Account"]
categories:  ["BLOCKCHAIN" ]
---

### Intro—  Overview

#### ·blockchain development：

![](/mdimg/image-20230618152900230.png)

#### ·ethereum development：

![image-20230618153540809](/mdimg/image-20230618153540809.png)

#### ·eth component：

![image-20230618160139866](/mdimg/image-20230618160139866.png)

#### ·以太币发行规则：

**矿前众筹的以太币还是占供应量的大多数**
![](/mdimg/image-20230621145407749.png)


1）block rewards：每产生一个新的区块就会有一笔固定的奖励给矿工

2）uncle rewards：某些较晚被挖出来的区块，不能成为主区块链的组成部分，因此在比特币中这些区块叫做孤块，从而被完全舍弃；但在以太币中这些被叫做叔块，并且可以被引用。若该叔块在之后的区块链中作为叔块被引用则挖出叔块的挖矿者可以得到7/8的奖励

3）uncle referencing rewards：矿工每引用一个叔块可以得到区块奖励的1/32（但最多引用2个叔块）

——这样的一套基于pow的奖励机制，叫做以太坊的GOSHT协议

#### ·GOSHT协议：

原由：比特币出块时间一般为10min，以太坊出块时间设计为12s左右，这种快速确认会带来区块的高作废率，链的安全性也随之降低

理解：
![](/mdimg/image-20230619120524911.png)

#### ·图灵完备：

#### ·去中心化应用DApp：

基于以太坊可创建smart contract 来构建DApp，组成部分至少为区块链上的智能合约以及web前端用户界面

#### ·代币token：

### No .1 Started with Ethereum

#### 1. Ethereum definition 

Ethereum是一个建立在区块链技术之上的**去中心化应用平台**。它允许任何人在平台上建立和使用通过区块链技术运行的去中心化应用（DApp）。

 DApp和现在互联网C/S架构的应用不同，其后端是一个有N个节点计算机（矿工）组成的网络，

在前端，用户通过自己的钱包处理自己的数据，在后端核心逻辑使用智能合约运行在区块链上，实现去中心。

Dapp与客户端连接的节点，只是网络中的一份子，它不单独处理来自用户的请求（这个请求通常称之为“交易”），而是要把用户的请求广播到整个网络，待整个网络达成共识之后，整个请求才算处理完成

![](/mdimg/image-20230628153531046.png)

#### 2. smart contract

智能合约是以太坊上运行的程序，和其他程序一样，它由代码和数据组成的。智能合约中的数据也称为“状态”，因为整个区块链就是由所有数据的确定的一个状态机。一旦部署到区块链上，智能合约就成为一个不可更改和可执行的程序，可以被网络上的节点共享和执行。

以太坊智能合约是 “图灵完备”的，因此理论上我们可以用它来编写能做任何事情的程序。 以下为一个简单的计数器合约

    pragma solidity ^0.8.0;
    contract Counter {
        uint counter;
        constructor() {
            counter = 0;
        }
    
        function count() public {
            counter = counter + 1;
        }
    }

#### 3. Ethereum Accounts

在比特币中运用的是基于交易的账户模型，使用UTXO的结构存储有关用户余额的数据，这种模式下并没有显式的记录每个账户的资金， 其余额需自行计算用户具有私钥的UTXO的总值。（隐私性强，但实用性不佳）

以太坊中基于账户的模式，每个账户都包括了一个余额balance和以太坊特殊定义的数据（代码和内部存储），以太坊中有两类账户：

#### 1）外部用户账户EOA

该类账户被公钥-私钥对控制（由人控制），可用来进行交易的发送（转币或触发合约调用代码）其中主要包含有对应的以太币余额，但没有关联代码

#### 2）合约账户

该类账户被存储在账户中的代码控制，有对应的以太币balance和关联代码和自己存储空间，可通过交易或来自其他合约的调用消息来触发代码执行，并且可以操作自己的存储空间
![](/mdimg/image-20230628161048096.png)

【注】：**只有外部用户账户可以发起交易（主动行为），合约账户只能被动地响应动作，并且所有的手续费 Gas 只能由外部账号支付**
![](/mdimg/image-20230629173146637.png)


**账户状态**

账户状态有4个基本组成部分
![](/mdimg/image-20230629174719123.png)


外部用户账户和合约账户，它们都是用同样的地址形式来表示，在 EVM 层面是一样的，地址形式是一个20字节的16进制数。

外部用户账户的地址是由私钥推倒出来的，合约账户的地址则由创建者的地址和nonce计算得到

**nonce** 

如果账户是一个外部用户账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号

【注】：以太坊中有两种nonce ， 一种是账号nonce——表示一个账号的交易数量；一种是工作量证明nonce——一个用于计算满足工作量证明的随机数。

#### 4. EVM

#### 1）def

以太坊虚拟机（Ethereum Virtual Machine），是智能合约的运行环境， 用来执行以太坊上的交易。 可以把EVM当做JVM来理解，EVM 同样是一个程序运行的容器，合约通常以solidity语言编写后，通过EVM编译器编译为字节码，最终通过客户端部署到区块链网络中

以太坊虚拟机是一个被沙箱封装起来、完全隔离的运行环境，在EVM中运行的代码无法访问网络、文件系统和其他进程， 只能访问内部信息

#### 2）EVM兼容链

繁荣的以太坊生态导致各大公链意识到与其开发自己特色的虚拟机，不如主动兼容以太坊虚拟机，从而可快速的承接以太坊应用

目前比较流行的 EVM 兼容链有：Polygon 链、BNB 链（BSC）、OK链、Avalanche C 链、Fantom 等。他们和以太坊链一样，使用相同的地址格式，使用相同的 EVM 代码，支持以太坊开发工具及钱包，但是这些 EVM 链各自定义了自己的共识机制，并且使用自己的原生币支付 Gas 手续费，因此手续费更低。

每一个链有自己的chainId 和 相应的节点 RPC， 我们可以在 MetaMask 等钱包通过添加自定义网络 RPC（`Custom RPC`） 来添加

#### 5. Ethereum Client

以太坊客户端是一个软件应用程序，是以太坊网络中的节点程序，运行节点程序就可以加入的区块链网络中，成为一个节点。这个节点程序可以完成如创建账号、发起交易、部署合约、执行合约、挖掘区块等工作。

常见的以太坊客户端有： 
![](/mdimg/image-20230624102009505.png)

以太坊虚拟机本身运行在以太坊节点客户端上
![](/mdimg/image-0230629193456052.png)

#### 6.Ethereum wallet

以太坊钱包是进入以太坊系统的门户，它包含了私钥，可以代表我们创建和广播交易，常见的wallet有：

1）metamask    一种浏览器扩展钱包，可在浏览器上运行，可以和Remix配合使用，用来部署和执行智能合约

2）jaxx    可在各种操作系统上运行的多平台、多币种的钱包

3）myetherwallet   基于web的钱包，可在任何浏览器中运行

#### 7. Gas

前面提到，在EVM上运行的智能合约是 “图灵完备”的，理论上可以编写能做任何事情的程序。既然如此，恶意的执行者就可以通过执行一个包含无限循环的交易轻易地让网络瘫痪。

以太坊通过每笔交易收取一定的费用来保护网络不受蓄意攻击，这一套收费的机制称为 Gas 机制

Gas 是衡量一个操作或一组操作需要执行多少” 工作量” 单位。例如，计算一个Keccak256加密哈希函数，每次计算哈希时需要30个 Gas ，再加上每256位被哈希的数据要花费6个 Gas 。EVM上执行的每个操作都会消耗一定数量的 Gas ，而需要更多计算资源的操作也会消耗更多的 Gas 。

> 理解：可以把 Gas 看做是以太坊虚拟机的运行燃料，它在每执行一步的时候消耗一定的 Gas ， 如果给定的 Gas 不够，无论执行到什么位置，，将会触发一个 out-of- gas 异常，当前交易所作的所有状态修改都将被还原。

**Gas price**&**Gas limit**

如果 Gas 仅仅是一个“工作量”单位，那怎么支付费用呢？还有另一个概念—— Gas price。其实每笔交易都要指定Gas limit及愿意为单位 Gas 支付的 Gas 价格，这是两者的结合， `Gas 预算` * `Gas 价格` = 交易预算。

`gas limit` > `实际使用的 gas` ， 交易才能顺利执行， 否则触发`out of gas` 交易回滚， 如果执行结束还有Gas剩余，这些Gas将被返还给发送交易账户。这也是称为交易预算的原因，由于链上状态的不断更新，很多时候无法完全准确测算交易费用，在实际提交交易时， `gas limit` 通常开发工具估算，`gas price` 用户指定（钱包提供参考值）， 矿工通过gas price 对交易排序。

#### 8. Ethereum Transaction

比特币交易非常简单，就是进行货币的转移。归纳为交易TO谁，FROM谁和 AMOUNT（多少钱）。而以太坊与之很大的不同在于其交易还有一个DATA字段。DATA字段适用于三种类型的交易：

**1）普通交易**

TO ：收款地址

FROM ：谁发出

AMOUNT ：发送多少

DATA ：留空或留言信息

eg：

```
{
to: '0x687422eEA2cB73B5d3e242bA5456b782919AFc85',
value: 0.0005,
data: "0x" // 也可以附加消息
}
```

**2）创建合约**

TO ：留空（这就是触发创建智能合约的原因）

FROM ：谁创建

AMOUNT ：可以是0或任何数量的以太币，它是我们想要给合约的存款

DATA ：包含编译为字节码的智能合约代码

eg：

```
{
  to: '',
  value: 0.0,
  data: "0x6060604052341561000c57xlb60405160c0806……………"
}
```

**3）调用合约**

TO： 目标合约账户地址

DATA： 包含函数名称和参数——标识如何调用智能合约函数

FROM ：谁调用

AMOUNT ： 可以是0或任意数量的以太币，例如可以支付给合约的服务费用

eg：

```
{
  to: '0x687422eEA2cB73B5d3e242bA5456b782919AFc85’, //合约地址
  value: 0.0,
  data: "0x06661abd"
}
```

函数调用信息封装在DATA字段中，把这个交易信息发送到要调用的智能合约的地址

**具体交易数据结构**

交易是包含以下数据的序列化二进制消息：
![](/mdimg/image-20230629201118717.png)
####  9. Ether

以太坊的货币叫做以太币ETH，对于用户来讲，最常用的是ether，1个ether就是我们常说的一个以太币（通常也简称为以太），对于开发者来说可能最常用的是wei, 它是以太币的最小单位， 其他的单位包括finney、szabo，其中wei还有几个衍生的单位：Kwei、Mwei以及Gwei

1 ether == 10^3 finney（即1000 finney）
1 ether == 10^6 szabo
1 ether == 10^18 wei
1 Gwei == 10^9 wei
1 Mwei == 10^6 wei

#### 10. Ethereum  Network

以太坊中有不同的网络，平常我们所说的以太坊一般是它的主网络，它是真正的以太坊区块链，**主网网络**是真正的价值网络，我们需要使用真实的以太币、BNB 等原生币进行交易。

而我们为了进行测试等工作还可以使用**测试网络**，测试网络会提供水龙头让开发者可以领取免费测试币。例如以太坊提供了`Goerli` 和 `Sepolia` 测试网 ， `Polygon` 提供了 `Mumbai` 测试网

#### 11. Ethereum key

1）private key   以太坊私钥是一个256位的随机数，用于发送以太的交易中创建签名来证明资金的所有权

2）public key    以太坊公钥是由私钥通过椭圆加密曲线secp256k1算法单向生成的512位数

3）address        地址是由公钥的keccak256单向哈希取最后20个字节派生出的标识符

### No.2 Contract development basic

#### 1. Remix IDE

 Remix 是在以太坊上构建的最简单的开发工具，它无需安装，可以直接快速上手。并且拥有大量插件来扩展其体验；Remix 可帮助我们直接在浏览器中编写 Solidity 代码，并提供用于测试、调试和将智能合约部署到区块链的工具。
![](/mdimg/image-20230629202630714..png)

#### 1）new contract

新建合约文件可以点击新建文件、也可以从本机或 GitHub 加载文件
![](/mdimg/image-20230630151919050.png)

#### 2）contract coding

新建一个counter.sol计数器合约，在文件编辑区域输入counter合约代码：

    pragma solidity ^0.8.0;
    
    contract Counter {
        uint counter;
        constructor() {
           counter = 0;
        }
    
        function count() public {
           counter = counter + 1;
        }
    
        function get() public view returns (uint) {
           return counter;
        }
    }

该合约会区块链上存储一个计数器变量 `counter`， `counter` 值将会被永久保存在区块链上。`count()`函数让计数器加1，`get()`函数用来获取计数器值。这里不需要编写入口方法（如main方法），每一个函数都可以被单独调用，编译器会帮助合约生成main入口函数，EVM 在入口函数里用函数选择器去匹配调用的函数。

#### 3）contract compile

代码编写之后进行编译，切换到`编译`功能， 选择编译器版本，进行编译
![](/mdimg/image-20230630155855981.png)

合约编译成功后，会输出两个重要的内容： ABI  和 Bytecode 字节码

·ABI： Application Binary Interface，即应用程序二进制接口，ABI 用来描述当前合约的所有接口，当我们与合约交互时，就需要使用 ABI

·Bytecode： 部署合约所需的字节码（也称为创建时字节码），部署合约时，就是把该字节码作为交易的输入数据发送链上

#### 4）contract deploy

编译之后就可以将合约部署到区块链网络上，部署的流程一般为：

1. 在本地的开发者网络（模拟网络）进行部署，测试及验证代码逻辑的正确性
2. 在测试网络进行灰度发布
3. 一切成功后部署在主网

Remix中 提供模拟网络环境， 可以通过如下图方式选择不同的环境，也可以通过 Metamask 连接到真实的区块链网络进行部署
![](/mdimg/image-20230630162114169.png)

#### ·deploy to VM

选择 `Remix VM(Merge)` ，它与当前以太坊主网（以太坊合并之后）运行的虚拟机功能一样，然后点击“Deploy” 部署：

选择使用账号、设置交易 [GasLimit](https://decert.me/tutorial/solidity/ethereum/evm_core#gas)、选择发送到合约金额、选择要部署的合约（默认选择当前编辑的合约文件）。

使用默认值即可
![](/mdimg/image-20230630193350498.png)

点击部署时，会发起一笔 [创建合约交易](https://decert.me/tutorial/solidity/ethereum/evm_core#调用合约方法)， 交易完成后，会在链上生成一个[合约地址](https://decert.me/tutorial/solidity/ethereum/evm_core#账户)， 同时在右下方`控制台/日志区`看到交易详情。
![](/mdimg/0230630194237703.png)

#### ·deploy to net

在 Remix 的环境里选择`Injected Provider - MetaMask`,Remix 会加载我们在 MetaMask 中选择的网络.

部署到真实的网络时，需要一个有余额的账号，否则就没办法发起交易。 如果是测试网络，则可以通过水龙头获取测试币

点击“Deploy” 部署合约，例如把合约部署到 Goerli 测试网络上， MetaMask 会弹出一个交易确认对话框，让我们确认交易费用，点击“确认”时，同时会对这笔交易签名，并发送到 Goerli 网络中
![](/mdimg/image-20230630194610737.png)

#### 5）use contract

合约部署后，在功能区的下方会出现智能合约部署后的地址以及合约所有可以调用的函数，

点击count和get两个按钮，就可以调用对应的合约函数，点击count时，会发起一笔交易，交易打包后，计数器变量加1，点击get可以获得当前计数器的值
![](/mdimg/image-20230630200110794.png)

#### 2. MetaMask

详细添加创建等操作：https://decert.me/tutorial/solidity/tools/metamask

### 